#pragma config(Sensor, S1, leftsensor, sensorEV3_Touch, modeEV3Bump)
#pragma config(Sensor, S4, rightsensor, sensorEV3_Touch, modeEV3Bump)
#pragma config(Motor, motorA, rightmotor, tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor, motorD, leftmotor, tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int randomBiasedWalk(int directionDistro);

//The base speed of the robot.
int BASE_SPEED = 50;
//How much faster a motor should go if the car is veering in that direction.
int VEER_SPEED_OFFSET = 25;
//How much faster a motor should go if the car is veering in that direction.
int TURN_SPEED_OFFSET = 10;
//Amount of time to wait before moving after both bumpers are hit.
int SIMUL_BUMP_WAIT = 2000;
//The amount of time that can elapse between bumper hits to be considered simultaneous.
int TIME_BETWEEN = 100;
//The amount of time that the robot will reverse upon collision.
int REVERSE_TIME = 1500;
//The amount of time that the robot will turn after reversing.
int TURN_TIME = 1100;
//The amount of time before, if the robot has just reversed after a simultaneous bump,
//we allow it to randomly generate which direction to turn after the next bump.
int TURN_AGAIN_BUFFER = 8000;
//The default chance that the robot has to veer right upon swaggering.
//If set to 50, then it has even odds of veering right or left.
int VEER_RIGHT_CHANCE = 50;
//How much to offset the odds of veering right upon each time we veer right without veering left.
int DISTRO_OFFSET = 10;
//The minimum and maximum times allowed for a swerve before it may change direction.
int SWERVE_DUR_MIN = 500;
int SWERVE_DUR_MAX = 1500;

task main() {
	int lastSimulBumpedTime = 0;
	int driveTime = 0;
	int directionDistro = 0;
	resetBumpedValue(S1);
	resetBumpedValue(S4);

	int lastBumpedTime = 0;
	int rightBumper = false;
	int leftBumper = false;
	int turnDirection = random[2];

	//Main loop. Primarily allows the robot to drive until a bumper
	//has been hit, and then takes action accordingly.
	repeatUntil (0) {
		lastBumpedTime = nSysTime;
		leftBumper = getBumpedValue(S1);
		rightBumper = getBumpedValue(S4);

		if (leftBumper || rightBumper) {
			//Bump detected. Check to see if it is both.
			repeatUntil (nSysTime - lastBumpedTime >= TIME_BETWEEN) {
				if (getBumpedValue(S1)) leftBumper = true;
				if (getBumpedValue(S4)) rightBumper = true;
			}

			if (leftBumper && rightBumper) {
				playSound(soundBeepBeep);
			}
			setMotorSpeed(motorA, -1 * BASE_SPEED);
			setMotorSpeed(motorD, -1 * BASE_SPEED);
			sleep(REVERSE_TIME);

			if (leftBumper && rightBumper) {
				setMotorSpeed(motorA, 0);
				setMotorSpeed(motorD, 0);
				sleep(SIMUL_BUMP_WAIT);

				//If a long enough time has passed since the last simultaneous bump,
				//it should be safe to randomly generate which direction to turn.
				//Otherwise, maintain the most recent direction.
				if (nSysTime - lastSimulBumpedTime > TURN_AGAIN_BUFFER) {
					turnDirection = random[2];
			  }
				lastSimulBumpedTime = nSysTime;

			} else if (rightBumper) {
				turnDirection = 0;
			} else {
				turnDirection = 1;
			}

			if (turnDirection) {
				//Turn right.
				setMotorSpeed(motorA, BASE_SPEED + TURN_SPEED_OFFSET);
				setMotorSpeed(motorD, (BASE_SPEED + TURN_SPEED_OFFSET) * -1);
				sleep(TURN_TIME);
		  } else {
		  	//Turn left.
		  	setMotorSpeed(motorA, (BASE_SPEED + TURN_SPEED_OFFSET) * -1);
				setMotorSpeed(motorD, BASE_SPEED + TURN_SPEED_OFFSET);
				sleep(TURN_TIME);
			}

			directionDistro = 0;
		}

		if (nSysTime - driveTime > 0) {
			//Time for the car to randomly travel in a new direction.
			directionDistro = randomBiasedWalk(directionDistro);

			//Randomly determine when the car should choose a new direction.
			//The car will turn for a random amount of time within an allowed range.
			driveTime = nSysTime + (random[SWERVE_DUR_MAX - SWERVE_DUR_MIN] + SWERVE_DUR_MIN);
		}

		resetBumpedValue(S1);
		resetBumpedValue(S4);
	}
}

int randomBiasedWalk(int directionDistro) {
	if (random[100] > (VEER_RIGHT_CHANCE + directionDistro * DISTRO_OFFSET)) {
			setMotorSpeed(motorA, BASE_SPEED + VEER_SPEED_OFFSET);
			setMotorSpeed(motorD, BASE_SPEED);
			return ++directionDistro;
	  } else {
	  	setMotorSpeed(motorA, BASE_SPEED);
			setMotorSpeed(motorD, BASE_SPEED + VEER_SPEED_OFFSET);
			return --directionDistro;
		}
}
