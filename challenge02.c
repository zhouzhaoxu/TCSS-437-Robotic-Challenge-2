#pragma config(Sensor, S3,     sonar,         sensorEV3_Ultrasonic)
#pragma config(Sensor, S1,     colourleft,         sensorEV3_Color)
#pragma config(Sensor, S4,     colourright,         sensorEV3_Color)
#pragma config(Motor,  motorB,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//The default speed of the robot.
#define DEFAULT_SPEED 50
//How close the robot needs to be for an obstacle to be detected.
#define MAX_DISTANCE 90
//How close the robot should get to an obstacle in cm
#define MIN_DISTANCE 8
//A value used to specify that no obstacles are currently detected.
#define OUT_OF_BOUNDS 255
//The slope used in the linear equation to calculate the robot's speed based on
//it's distance from an obstacle
#define OBSTACLE_EQ_SLOPE 1.22
//The maximum time allowed between two successive sonar signals for it to be considered valid.
#define DETECT_BUFFER_TIME 100

//How long the robot should stop before reversing from an obstacle.
#define RETREAT_STOP_TIME 3000
//How long the robot should reverse from the obstacle.
#define RETREAT_REVERSE_TIME 1000
//How long the robot should turn from the obstacle.
#define RETREAT_TURN_TIME 500

task sonarTask();
task lightTask();
void retreatFromObstacle(void);
int getSpeedFromDistance(int distance);

int distanceFrom = OUT_OF_BOUNDS;

task main() {
	int motorSpeed = 0;

	startTask(sonarTask);
	startTask(lightTask);
	setMotorSpeed(motorLeft, DEFAULT_SPEED);
	setMotorSpeed(motorRight, DEFAULT_SPEED);
	while (true) {
		if (distanceFrom < MAX_DISTANCE) {
			if (distanceFrom <= MIN_DISTANCE) {
				retreatFromObstacle();
		  } else {
		    motorSpeed = getSpeedFromDistance(distanceFrom);
			  setMotorSpeed(motorLeft, motorSpeed);
			  setMotorSpeed(motorRight, motorSpeed);
		  }

	  } else {
	    //TODO: Wander
	    setMotorSpeed(motorLeft, DEFAULT_SPEED);
			setMotorSpeed(motorRight, DEFAULT_SPEED);
	  }
  }
}

//Calculate the speed, from 100 to 0, based on the robot's distance
//from an obstacle.
int getSpeedFromDistance(int distance) {
	int speed = OBSTACLE_EQ_SLOPE * (distance - MIN_DISTANCE);
	if (speed < 0) speed = 0;
	return speed;
}

//Stop for a few seconds, then reverse and turn away from the obstacle.
void retreatFromObstacle(void) {
	sleep(RETREAT_STOP_TIME);

	setMotorSpeed(motorLeft, -1 * DEFAULT_SPEED);
	setMotorSpeed(motorRight, -1 * DEFAULT_SPEED);
	sleep(RETREAT_REVERSE_TIME);

	int direction = random[2];
	if (direction) {
		//Turn left
		setMotorSpeed(motorLeft, DEFAULT_SPEED);
		setMotorSpeed(motorLeft, -1 * DEFAULT_SPEED);
  } else {
    //Turn right
    setMotorSpeed(motorLeft, -1 * DEFAULT_SPEED);
		setMotorSpeed(motorLeft, DEFAULT_SPEED);
  }
  sleep(RETREAT_TURN_TIME);
}

//Continually check to see if an obstacle is detected, and change
//global variable distanceFrom with the distance from the obstacle.
task sonarTask() {
	int lastDetectTime = 0;
	int tempDetect = OUT_OF_BOUNDS;
	while (true) {
		tempDetect = SensorValue[sonar];
		if (tempDetect < MAX_DISTANCE) {
			//We require a small window of time for two successive detections
		  //to avoid erroneous obstacle collision.
			if (nSysTime - lastDetectTime < DETECT_BUFFER_TIME) {
				distanceFrom = tempDetect;
		  }
		  lastDetectTime = nSysTime;
    } else {
      distanceFrom = OUT_OF_BOUNDS;
    }
    displayBigTextLine(4, "Dist: %3d cm", distanceFrom);
  }

}

task lightTask() {

}
